(* JsCoq
 * Copyright (C) 2015 Emilio Gallego / Mines ParisTech
 *
 * LICENSE: GPLv3+
 *)

(* Library manager for JsCoq

  Due to the large size of Coq libraries, we need to perform some
  caching and lazy loading in order to make the application usable.
*)
open Lwt

type coq_file =
  | VO  of string
  | CMA of string

(* Information about a Coq library. Note that we could access
   Loadpath.t too, but I've opted to keep this module separated from
   Coq *)
type coq_pkg = {
  name  : string list;
  files : (coq_file * Digest.t) list;
}

(* We likely want these to be Hashtbls of just js arrays. *)
type cache_entry = {
  (* url        : Js.js_string; *)
  content    : Js.js_string Js.t;
  md5        : Digest.t;
  }

type byte_cache_entry = {
  md5     : Digest.t; (* Or other signature *)
  (* should this be a OCAML string? *)
  js_code : Js.js_string;
}

(* Main file_cache *)
let file_cache : (Js.js_string Js.t, cache_entry) Hashtbl.t =
  Hashtbl.create 100

(* Package list, should be autogenerated *)
let packages = []

let init () = ()
  (* Lwt.iters preload_package packages *)

(*
let preload_package pkg =
  let base_url = build_url pkg.name in
  Lwt_seq (preload_file base_url) pkg.files

 *)

(* let preload_file base_url (file, hash) : Lwt.unit = *)
let preload_file base_url (file, hash) : unit Lwt.t =
  let unwrap file = match file with
    | VO  name -> (false, name)
    | CMA name -> (true, name)                  in
  let open XmlHttpRequest                       in
  let (is_cma, name) = unwrap file              in
  Jslog.printf Jslog.jscoq_log "Start preload file %s\n%!" name;
  perform_raw ~response_type:ArrayBuffer ("filesys/" ^ base_url) >>= fun frame ->
  (* frame.code contains the request status *)
  (* Is this redudant with the Opt check? I guess so *)
  if frame.code = 200 || frame.code = 0 then
    Js.Opt.case
      frame.content
      (fun ()        -> Lwt.return_unit)
      (fun raw_array ->
       let bl    = raw_array##byteLength                              in
       let u8arr = jsnew Typed_array.uint8Array_fromBuffer(raw_array) in
       (* Add to file cache, pity of all the unneeded marshalling *)
       let s = Bytes.create bl in
       for i = 0 to bl - 1 do
         Bytes.set s i @@ Char.chr @@ Typed_array.unsafe_get u8arr i
       done;
       let cache_entry = {
         content = Js.bytestring (Bytes.to_string s);
         md5     = Digest.bytes s;
       } in
       Hashtbl.add file_cache (Js.string base_url) cache_entry;
       Jslog.printf Jslog.jscoq_log
         "Cache %s [%d/%d/%d/%s]\n%!"
          base_url bl (u8arr##length)
          (cache_entry.content##length)
          (Digest.to_hex cache_entry.md5);
       Lwt.return_unit
      )
  else
    Lwt.return_unit

(*
  let handler xml =
      let md5 = Digest.md5 xml##contents (casts, etc...)
      if md5 <> hash then
         notifyError(base_url + name);
      add_to_cache contents ...;
      let next () =
        if cma then
           preload_bytecode md5
	else cont ()
      do_next ()
 *)

let is_bad_url _ = false

let coq_resource_req url =
  (* Wait until we have enough UI support *)
  (* Jslog.printf Jslog.jscoq_log "coq_resource_req %s\n%!" (Js.to_string url); *)
  if not @@ is_bad_url url then
    try let c_entry = Hashtbl.find file_cache url in
        Jslog.printf Jslog.jscoq_log "coq_resource_req %s\n%!" (Js.to_string url);
        Js.Unsafe.global##lastCoqReq <- url;
        Some c_entry.content
    with Not_found ->
      (* Js.Unsafe.global##lastCoqReq <- Js.string "Not Found"; *)
      None
  else
    begin
      Js.Unsafe.global##lastCoqReq <- Js.string "Bad URL";
      None
    end
