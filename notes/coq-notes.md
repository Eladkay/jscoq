# Notes on Coq, and the Coq/API:

This document contains some random and incomplete information we
gathered on while working with Coq's API, as well as some constructive
(sic) comments and criticisms (marked with _fixme?_).

For the purposes of this commentary, we use a special-purpose branch
https://github.com/ejgallego/coq/tree/ejga-commentary so links to code
are stable.

## STM overview

Coq 8.5 has a new document model API called STM, which allows the
consumer to build Coq documents as a DAG. This enables

The current version is functional but doesn't seem complete. Also,
some _technical debt_ and a fair amount of compatibility code seems present.

More details can be found in the ITP 2015 paper https://hal.inria.fr/hal-01135919

### Operation Overview

The basic idea of the stm API is to represent Coq document as a Direct
Acyclic Graph. This should enable Coq process the document
asynchronously/in parallel.

Every node of the document is assigned a unique id, which when used as
a state represents the path from the root of the tree to that
particular state. Things are a bit tricky sometimes:
the core of Coq is very stateful and some commands produce
_interesting_ side effects.

The user can "append" to the document, and request Coq to process
particular paths (or all of them). A typical API user-workflow loop in pseudocode is:

```
while(new_command) {

  old_state := cur_state

  try
    cur_state := add_to_doc(cur_state, new_command)
  catch ParsingError(..) -> ...

  try
    execute(cur_state);
  catch Error (..) -> -- go back to the old state
                      cur_state := old_state;
                      edit_at(cur_state)
end while
```

Note that in the above pseudo code we have used `try ... catch ...`
blocks to capture errors, in fact, Coq will both generate an exception
and call a hook for reporting errors, completion, etc...

### Basic Datatypes

The basic datatypes involved are:

* [`Stateid.t`](https://github.com/ejgallego/coq/blob/ejga-commentary/lib/stateid.mli)

  Abstract type of state denoting a particular document. This is the
  main type over which the stm works. They are always generated by the STM.

* [`edit_id`](https://github.com/ejgallego/coq/blob/ejga-commentary/lib/feedback.mli#L30-33)

  An integer used to denote a particular user input. `edit_id`s are
  used when we give input to the STM by that input may not be valid
  (i.e: parsing error) so the STM cannot build a valid document.

  _fixme?_: There also exists an `edit_or_state_id` type, but in my
  opinion this type should be totally removed.

* [`feedback`](https://github.com/ejgallego/coq/blob/ejga-commentary/lib/feedback.mli#L37-63)

  This type represents the STM gives to its user. Currently it includes very varied information.

  _fixme?_: Related to the previous fixme, the feedback type should be
  split into particular cases and the `edit_or_state_id` removed. But
  this is a big clenaup.

* [`message`]((https://github.com/ejgallego/coq/blob/ejga-commentary/lib/feedback.mli#L12-22))

  _fixme?_: As noted in the Coq sources, this is the old type of
  feedback, which doesn't include information about which particular
  node of the document we are. It should be removed/encapsulated into
  a compat layer.

### Document Building

* [`add`](https://github.com/ejgallego/coq/blob/ejga-commentary/stm/stm.mli#L22-24)

  `add` builds a document by appending a new node.

   ```ocaml
(* [add ontop check vebose eid s] *)
val add : ontop:Stateid.t -> ?newtip:Stateid.t -> ?check:(located_vernac_expr -> unit) ->
  bool -> edit_id -> string ->
    Stateid.t * [ `NewTip | `Unfocus of Stateid.t ]
   ```

   It basically parses the input text and returns the new document
   id. If parsing fails, it will produce an exception and send
   feedback with the specified `edit_id`.

   _todo_: I have no clue when `Unfocus` is returned.

* [edit_at](https://github.com/ejgallego/coq/blob/ejga-commentary/stm/stm.mli#L40)

   ```ocaml
val edit_at : Stateid.t -> [ `NewTip | `Focus of focus ]
   ```

   The STM api is stateful in certain way, `edit_at` "resets" it to
   the the specified state. For instance, after an error, it must be
   called with the last previous know good state.

   _todo_: I have no clue what `Focus` is, and when is returned.

* [`observe`](https://github.com/ejgallego/coq/blob/ejga-commentary/stm/stm.mli#L45)

   ```ocaml
val observe : Stateid.t -> unit
   ```

   `add` just builds the document, `observe` will actually "run" Coq
    until the specified `Stateid.t`.

* The stm API is completed by other functions, such as:

   ```ocaml
val init : unit -> unit
val get_current_state : unit -> Stateid.t
   ```

### Feedback

The main instrument used by the STM to communicate back is the
`feeeback` datatype. Feedback tries to unify all kind of reporting,
from debug/informative to error handling, which was previously
separated in Coq, with "informative" output taken care of by printing
functions and error handling done via exceptions.

As noted in the coq sources, the current implementation seems a bit in
flux due to compatibility constraints.

Operations related to feedback are split among three modules:

* [`Feedback`](https://github.com/ejgallego/coq/blob/ejga-commentary/lib/feedback.mli)

  Datatype definition and serialization occur here.

* [`Pp`](https://github.com/ejgallego/coq/blob/ejga-commentary/lib/pp.mli#L164)

  Surprisingly, here we have the main functions used by Coq to give
  feedback back to the user.

  First, we find the old-style functions `msg_*` that used to output
  text to `stdout/stderr`. They still do, unless `log_via_feedback
  ()` is called, then a feedback message will produced instead.

  The main function called from Coq is
  [`feedback`](https://github.com/ejgallego/coq/blob/ejga-commentary/lib/pp.mli#L175-178)

  ```ocaml
val feedback :
  ?state_id:Feedback.state_id -> ?edit_id:Feedback.edit_id ->
  ?route:Feedback.route_id -> Feedback.feedback_content -> unit
  ```

  which will produce the corresponding feedback.

  _fixme_: Note the weird constraint on only one of `state_id` or
  `edit_id` being used. It should be fixed ASAP.

   Feedback consumers register with:

   ```ocaml
val set_feeder : (Feedback.feedback -> unit) -> unit
   ```

   Note that it seems only one consumer can be registered.

* [`Stm`](https://github.com/ejgallego/coq/blob/ejga-commentary/stm/stm.mli#L97)

  `Stm` has finer-grained `Hooks` for crucial events:

   ```ocaml
val state_computed_hook    : (Stateid.t -> in_cache:bool -> unit) Hook.t
val parse_error_hook       : (Feedback.edit_or_state_id -> Loc.t -> Pp.std_ppcmds -> unit) Hook.t
val execution_error_hook   : (Stateid.t -> Loc.t -> Pp.std_ppcmds -> unit) Hook.t
val unreachable_state_hook : (Stateid.t -> unit) Hook.t
val state_ready_hook       : (Stateid.t -> unit) Hook.t
   ```

   By default, this functions just call `feedback` with an appropriate
   constructor (usually `MsgError`) but ideally their implementation
   would be made mandatory by the users and as noted before, the
   `feedback` type specialized.

### More on Feedback

Maybe the future of feedback in Coq would be to have a "dispatch"
module where users register. It should replace all the `msg_*`
functions in `Pp`.

Several dispatch modules should be allowed to coexist, and they they
should be thread local, but that is another issue.

### Error handling.

Error handling currently is a bit schizophrenic, as there is some
overlap between the new error reporting using feedback and Coq's
kernel raising exceptions. This is not a big problem, but care must be
taken when using the STM API.

The approach CoqIDE takes is to wrap all the exceptions.

The error hooks in `Feedback` are set by default to send 

```ocaml
[in errors.mli]
exception UserError of string * std_ppcmds
exception AlreadyDeclared of std_ppcmds

[in proofs.ml etc...]
exception NoSuchProof
exception NoCurrentProof
exception FailedBullet of t * suggestion
```

## Other (minor) comments

### VM static initializers

`vm.ml` does a lot of static initialization. This is not good for a
wide variety of reasons, and very inconvenient for jscoq.

### Declare ML Module

`Declare ML Module` is unqualified, which is a bit inconvenient for
applications like jscoq that have to manage their own fs layout.
